## 숫자 변환하기 (BFS, DP, heapq)
- x->y, 최소연산횟수
- 1<=x<=y<=1000000
- #r1. x+n
- #r2. x*2
- #r3. x*3

### BFS
```Python3
from collections import deque
def solution(x, y, n):
    visited=set()
    q=deque([(x,0)]) #nx,cnt
    
    while q:
        nx,cnt=q.popleft() #x,0->nx,cnt
        if nx==y:
            return cnt
        for a in (nx+n,nx*2,nx*3):
            if a<=y and a not in visited: #unique
                visited.add(a)
                q.append((a,cnt+1))
    return -1
```

### DP
```Python3
def solution(x, y, n):
    #1<=x<=y<=1000000
    #최대 y*3+1 or 1000000*3+1
    dp=[float('inf') for _ in range(3*y+1)]
    dp[x]=0

    for i in range(x,y+1):

        dp[i+n]=min(dp[i+n],dp[i]+1)
        dp[i*2]=min(dp[i*2],dp[i]+1)
        dp[i*3]=min(dp[i*3],dp[i]+1)

    #print(dp)
    return dp[y] if dp[y]<1000000 else -1
```


### heapq (와일러스 연산자 := 도입)
```Python3
import heapq
def solution(x, y, n):
    def find(x,y,n,cnt):
        heap=[(cnt,y)]
        while heap:
            v=heapq.heappop(heap)
            if v[1]==x:
                return v[0]
            else:
                if v[1]-n>x:
                    heapq.heappush(heap,(v[0]+1,v[1]-n))
                elif v[1]-n==x:
                    return v[0]+1
                if (temp:=v[1]/2)>x:
                    if temp==v[1]//2:
                        heapq.heappush(heap,(v[0]+1,v[1]//2))
                elif v[1]//2==x:
                    return v[0]+1
                if (temp:=v[1]/3)>x:
                    if temp==v[1]//3:
                        heapq.heappush(heap,(v[0]+1,v[1]//3))
                elif v[1]//3==x:
                    return v[0]+1
        return -1
    return find(x,y,n,0)
```
